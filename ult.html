<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visor PDF</title>
  <!-- MathJax Configuration -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\$$', '\$$']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
  <!-- MathQuill CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.css" />
  <style>
    * { box-sizing: border-box; }
    body {
       font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
       margin: 0;
       background: #525659;
       color: #fff;
      overflow: hidden;
    }
    
    #app-header {
       padding: 8px 16px;
       background: #323639;
       display: flex;
       align-items: center;
       justify-content: space-between;
      border-bottom: 1px solid #5f6368;
      height: 56px;
      position: relative;
      z-index: 100;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .header-center {
      flex: 1;
      text-align: center;
      font-size: 14px;
      color: #e8eaed;
    }
    
    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .control-btn {
      background: transparent;
      border: none;
      color: #e8eaed;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .control-btn:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    #zoom-display {
      min-width: 60px;
      text-align: center;
      font-size: 13px;
    }
    
    #drop-zone {
      position: absolute;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #525659;
      z-index: 100;
    }
    
    #drop-zone.hidden {
      display: none;
    }
    
    .upload-area {
      border: 2px dashed #8ab4f8;
      border-radius: 8px;
      padding: 48px;
      text-align: center;
      background: rgba(138, 180, 248, 0.1);
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .upload-area:hover {
      background: rgba(138, 180, 248, 0.2);
      border-color: #aecbfa;
    }
    
    .upload-area.dragover {
      background: rgba(138, 180, 248, 0.3);
      border-color: #aecbfa;
    }
    
    .upload-icon {
      font-size: 48px;
      margin-bottom: 16px;
      color: #8ab4f8;
    }
    
    .upload-text {
      font-size: 18px;
      margin-bottom: 8px;
      color: #e8eaed;
    }
    
    .upload-subtext {
      font-size: 14px;
      color: #9aa0a6;
    }
    
    #file-input {
      display: none;
    }
    
    /* Contenedor con scroll vertical + navegaci√≥n horizontal */
    #pdf-container {
       position: absolute;
      top: 56px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow-y: auto;
      overflow-x: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 16px 0;
      background: #525659;
    }
    
    .page-wrapper {
       position: relative;
       background: #fff;
       box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      margin-bottom: 8px;
    }
    
    .anno-layer {
       position: absolute;
       top: 0;
       left: 0;
       pointer-events: none;
    }
    
    .page-number {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #9aa0a6;
    }
    
    .fullscreen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9999 !important;
      background: #525659 !important;
    }
    /* Ocultar header en pantalla completa */
    .fullscreen #app-header {
      display: none;
    }
    /* Ajustar container en pantalla completa */
    .fullscreen #pdf-container {
      top: 0 !important;
    }
    /* Indicador de navegaci√≥n */
    .nav-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      z-index: 200;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .nav-indicator.show {
      opacity: 1;
    }
    
    /* ========================================
       ESTILOS PARA NOTAS FLOTANTES AVANZADAS
       ======================================== */
    
    .note-icon {
      display: inline-block;
      cursor: pointer;
      position: absolute;
      margin: 0;
      padding: 4px;
      user-select: none;
      z-index: 900;
      font-size: 20px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }
    
    .note-icon:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    
    .note-icon.dragging {
      opacity: 0.7;
      cursor: move;
      z-index: 1000;
      transform: translate(-50%, -50%) scale(1.2);
    }
    .note-icon.deleting {
      background: rgba(255, 0, 0, 0.8);
      transform: translate(-50%, -50%) scale(0.8);
      opacity: 0.5;
    }
    
    .note-popup {
      position: absolute;
      background: #fff;
      border: 1px solid #ddd;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25);
      z-index: 1001;
      white-space: pre-wrap;
      pointer-events: auto;
      max-width: 350px;
      min-width: 200px;
      border-radius: 8px;
      color: #333;
      font-size: 14px;
      line-height: 1.4;
    }
    .note-popup .math-field {
      display: inline-block;
      margin: 2px;
      background: #f8f9fa;
      padding: 2px 4px;
      border-radius: 3px;
    }
    
    .note-textarea {
      position: fixed;
      z-index: 1500;
      border: 2px solid #8ab4f8;
      border-radius: 8px;
      padding: 12px;
      background: white;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      font-family: inherit;
      resize: both;
      min-width: 250px;
      min-height: 120px;
      color: #333;
      font-size: 14px;
      line-height: 1.4;
      outline: none;
    }
    .note-textarea:focus {
      border-color: #4285f4;
    }
    /* Estilos para MathQuill */
    .mq-editable-field,
    .mq-editable-field .mq-root-block {
      border: 1px solid #ddd !important;
      background: #f8f9fa !important;
      border-radius: 4px !important;
      padding: 4px !important;
      margin: 2px !important;
    }
    
    .mq-editable-field:focus {
      border-color: #4285f4 !important;
      box-shadow: 0 0 0 2px rgba(66, 133, 244, 0.2) !important;
    }
    /* Modal de informaci√≥n */
    .info-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 3000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .info-modal.hidden {
      display: none;
    }
    .info-content {
      background: #fff;
      border-radius: 12px;
      max-width: 500px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .info-header {
      background: #f8f9fa;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e9ecef;
    }
    .info-header h3 {
      margin: 0;
      color: #333;
      font-size: 18px;
    }
    .close-info {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    .close-info:hover {
      background: #e9ecef;
    }
    .info-body {
      padding: 20px;
      color: #333;
      line-height: 1.6;
    }
    .info-body kbd {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
      border: 1px solid #dadce0;
    }
    /* Indicador visual para crear notas */
    .creating-note {
      cursor: crosshair !important;
    }
    .creating-note .page-wrapper {
      outline: 2px dashed #8ab4f8;
      outline-offset: 2px;
    }
    /* ========================================
       ESTILOS PARA PERSISTENCIA DE ARCHIVOS
       ======================================== */
    .file-status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
      padding-left: 8px;
      border-left: 1px solid #5f6368;
    }
    .status-indicator {
      font-size: 12px;
      color: #9aa0a6;
      padding: 4px 8px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
      min-width: 100px;
      text-align: center;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .status-indicator.saving {
      color: #fbbc04;
      background: rgba(251, 188, 4, 0.1);
    }
    .status-indicator.saved {
      color: #34a853;
      background: rgba(52, 168, 83, 0.1);
    }
    .status-indicator.error {
      color: #ea4335;
      background: rgba(234, 67, 53, 0.1);
    }
    .status-indicator.no-access {
      color: #9aa0a6;
      background: rgba(255,255,255,0.05);
    }
    /* Modal de permisos */
    .permission-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 4000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .permission-modal.hidden {
      display: none;
    }
    .permission-content {
      background: #fff;
      border-radius: 12px;
      max-width: 500px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .permission-header {
      background: #4285f4;
      color: white;
      padding: 20px;
      text-align: center;
    }
    .permission-header h3 {
      margin: 0;
      font-size: 20px;
    }
    .permission-body {
      padding: 24px;
      color: #333;
      line-height: 1.6;
      text-align: center;
    }
    .permission-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      margin-top: 20px;
    }
    .permission-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }
    .permission-btn.primary {
      background: #4285f4;
      color: white;
    }
    .permission-btn.primary:hover {
      background: #3367d6;
    }
    .permission-btn.secondary {
      background: #f8f9fa;
      color: #5f6368;
      border: 1px solid #dadce0;
    }
    .permission-btn.secondary:hover {
      background: #e8f0fe;
    }
    /* Notificaci√≥n toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #323639;
      color: #e8eaed;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 2000;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      border: 1px solid #5f6368;
      max-width: 300px;
    }
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .toast.success {
      border-left: 4px solid #34a853;
    }
    .toast.error {
      border-left: 4px solid #ea4335;
    }
    .toast.info {
      border-left: 4px solid #4285f4;
    }
    /* Loading indicator */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: #e8eaed;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <header id="app-header">
    <div class="header-left">
      <button class="control-btn" id="back-btn" disabled>‚Üê Atr√°s</button>
    </div>
    <div class="header-center" id="file-info">Visor PDF</div>
    <div class="header-right">
      <button class="control-btn" id="zoom-out">‚àí</button>
      <span id="zoom-display">100%</span>
      <button class="control-btn" id="zoom-in">+</button>
      <button class="control-btn" id="fullscreen-btn">‚õ∂</button>
      
      <!-- Indicador de estado de archivos -->
      <div class="file-status">
        <div class="status-indicator" id="file-status">
          <span>üìÅ</span>
          <span id="status-text">Cargando acceso...</span>
        </div>
        <button class="control-btn" id="folder-btn" title="Configurar carpeta">‚öôÔ∏è</button>
      </div>
      
      <button class="control-btn" id="info-btn" title="Ayuda">‚ÑπÔ∏è</button>
    </div>
  </header>

  <div id="drop-zone">
    <div class="upload-area" id="upload-area">
      <div class="upload-icon">üìÑ</div>
      <div class="upload-text">Seleccionar PDF</div>
      <div class="upload-subtext">Arrastra un archivo aqu√≠ o haz clic para seleccionar</div>
    </div>
    <input type="file" id="file-input" accept="application/pdf">
  </div>

  <div id="pdf-container">
    <div class="nav-indicator" id="nav-indicator"></div>
  </div>

  <!-- Modal de permisos -->
  <div id="permission-modal" class="permission-modal hidden">
    <div class="permission-content">
      <div class="permission-header">
        <h3>üóÇÔ∏è Acceso a Carpeta de Notas</h3>
      </div>
      <div class="permission-body">
        <p><strong>Para guardar autom√°ticamente tus notas</strong>, necesito acceso a una carpeta en tu computadora.</p>
        <p>Las notas se guardar√°n como archivos JSON y se cargar√°n autom√°ticamente cuando abras el mismo PDF.</p>
        <p><small>‚ö†Ô∏è Solo funciona en navegadores modernos (Chrome, Edge, etc.)</small></p>
        <div class="permission-buttons">
          <button class="permission-btn primary" id="grant-access-btn">üìÅ Seleccionar Carpeta</button>
          <button class="permission-btn secondary" id="skip-access-btn">Omitir</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de instrucciones -->
  <div id="info-modal" class="info-modal hidden">
    <div class="info-content">
      <div class="info-header">
        <h3>üìù Visor PDF H√≠brido</h3>
        <button class="close-info">√ó</button>
      </div>
      <div class="info-body">
        <strong>üéÆ Navegaci√≥n h√≠brida:</strong><br>
        ‚Ä¢ <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> Saltar p√°ginas (estilo Chrome)<br>
        ‚Ä¢ <kbd>‚Üë</kbd> <kbd>‚Üì</kbd> Scroll continuo vertical<br>
        ‚Ä¢ <kbd>F</kbd> Pantalla completa<br><br>
        
        <strong>üìù Notas:</strong><br>
        ‚Ä¢ <kbd>N</kbd> para crear notas en la p√°gina<br>
        ‚Ä¢ Haz clic donde quieras pegar la nota<br>
        ‚Ä¢ Arrastra üìù para mover dentro de la p√°gina<br>
        ‚Ä¢ Doble clic en üìù para editar<br>
        ‚Ä¢ <kbd>Ctrl+L</kbd> para LaTeX en notas<br>
        ‚Ä¢ Arrastra hacia arriba para eliminar<br><br>
        
        <strong>üîç Zoom:</strong><br>
        ‚Ä¢ <kbd>Ctrl</kbd> + <kbd>+</kbd> / <kbd>-</kbd> para zoom<br>
        ‚Ä¢ <kbd>Ctrl</kbd> + <kbd>0</kbd> para resetear<br>
        ‚Ä¢ Rueda del mouse + <kbd>Ctrl</kbd><br><br>
        <strong>üíæ Guardado Autom√°tico:</strong><br>
        ‚Ä¢ Las notas se guardan autom√°ticamente en archivos<br>
        ‚Ä¢ Se cargan autom√°ticamente al abrir el mismo PDF<br>
        ‚Ä¢ Usa ‚öôÔ∏è para configurar la carpeta de guardado<br>
        ‚Ä¢ Funciona sin conexi√≥n a internet<br><br>
        
        <small>Las notas persisten permanentemente en tu computadora</small>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@2.16.105/build/pdf.worker.min.js';</script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Iniciando aplicaci√≥n...');
      
      // ========================================
      // VARIABLES GLOBALES
      // ========================================
      const container = document.getElementById('pdf-container');
      const dropZone = document.getElementById('drop-zone');
      const uploadArea = document.getElementById('upload-area');
      const fileInput = document.getElementById('file-input');
      const fileInfo = document.getElementById('file-info');
      const zoomDisplay = document.getElementById('zoom-display');
      const zoomInBtn = document.getElementById('zoom-in');
      const zoomOutBtn = document.getElementById('zoom-out');
      const fullscreenBtn = document.getElementById('fullscreen-btn');
      const backBtn = document.getElementById('back-btn');
      let navIndicator = document.getElementById('nav-indicator');
      let pdfDoc = null;
      let currentZoom = 1.0;
      let isFullscreen = false;
      let currentPage = 1;
      let totalPages = 0;
      let pageWrappers = [];
      let isRendering = false; // NUEVO: Flag para evitar renderizados m√∫ltiples
      
      // Variables para notas avanzadas
      let activePopup = null;
      let activeIcon = null;
      let creatingNote = false;
      const MQ = MathQuill.getInterface(2);
      // Variables para persistencia de archivos
      let directoryHandle = null;
      let currentPdfName = null;
      let saveTimeout = null;
      let db = null; // Para IndexedDB

      // ========================================
      // FUNCIONES DE UTILIDAD
      // ========================================
      
      function showToast(message, type = 'info') {
        console.log(`Toast: ${message} (${type})`);
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 100);
        setTimeout(() => {
          toast.classList.remove('show');
          setTimeout(() => {
            if (document.body.contains(toast)) {
              document.body.removeChild(toast);
            }
          }, 300);
        }, 3000);
      }

      function updateFileStatus(status, text) {
        const statusEl = document.getElementById('file-status');
        const textEl = document.getElementById('status-text');
        
        statusEl.className = 'status-indicator ' + status;
        textEl.textContent = text;
      }

      // Helper para renderizar contenido HTML (incluyendo MathQuill)
      function renderContentInElement(element, htmlContent) {
        element.innerHTML = ''; // Limpiar contenido existente
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlContent;
        Array.from(tempDiv.childNodes).forEach(node => element.appendChild(node.cloneNode(true)));
        initMathFields(element); // Re-inicializar MathQuill para los nuevos elementos
      }

      // ========================================
      // CARGA DE PDF
      // ========================================
      
      async function loadPdf(url, filename) {
        console.log('Cargando PDF:', filename);
        
        try {
          // Limpiar completamente el contenedor
          clearContainer();
          container.innerHTML = '<div class="loading">Cargando PDF...</div>';
          
          dropZone.classList.add('hidden');
          backBtn.disabled = false;
          fileInfo.textContent = filename;
          currentPdfName = filename;
          
          console.log('Iniciando carga con PDF.js...');
          const loadingTask = pdfjsLib.getDocument(url);
          pdfDoc = await loadingTask.promise;
          totalPages = pdfDoc.numPages;
          currentPage = 1;
          
          console.log(`PDF cargado: ${totalPages} p√°ginas`);
          
          // renderAllPages se encargar√° de limpiar y a√±adir el nav indicator
          await renderAllPages();
          
          // Intentar cargar notas despu√©s de renderizar
          if (directoryHandle) {
            setTimeout(loadNotesFromFile, 500);
          } else if (supportsFileSystemAccess()) {
            // Si no hay handle, mostrar modal de permisos
            setTimeout(() => {
              showPermissionModal();
            }, 1000);
          } else {
            updateFileStatus('error', 'No compatible');
          }
          
          showToast(`PDF cargado: ${totalPages} p√°ginas`, 'success');
          
        } catch (error) {
          console.error('Error cargando PDF:', error);
          showToast('Error cargando PDF: ' + error.message, 'error');
          
          dropZone.classList.remove('hidden');
          backBtn.disabled = true;
          fileInfo.textContent = 'Visor PDF';
          currentPdfName = null;
        }
      }

      // NUEVA FUNCI√ìN: Limpiar completamente el contenedor
      function clearContainer() {
        console.log('Limpiando contenedor completamente...');
        
        // Remover todos los event listeners de las p√°ginas existentes
        pageWrappers.forEach(wrapper => {
          if (wrapper && wrapper.parentNode) {
            wrapper.parentNode.removeChild(wrapper);
          }
        });
        
        // Limpiar el contenedor DOM
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
        
        // Resetear variables
        pageWrappers = [];
        
        // Re-crear y a√±adir el nav indicator
        navIndicator = document.createElement('div');
        navIndicator.className = 'nav-indicator';
        navIndicator.id = 'nav-indicator';
        container.appendChild(navIndicator);
      }

      async function renderAllPages() {
        // NUEVO: Evitar renderizados m√∫ltiples simult√°neos
        if (isRendering) {
          console.log('Ya se est√° renderizando, saltando...');
          return;
        }
        
        isRendering = true;
        console.log('Renderizando todas las p√°ginas...');
        
        try {
          // Limpiar completamente el contenedor
          clearContainer();
          
          for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            try {
              console.log(`Renderizando p√°gina ${pageNum}...`);
              const page = await pdfDoc.getPage(pageNum);
              const scale = currentZoom * 1.5;
              const viewport = page.getViewport({ scale });
              
              const wrapper = document.createElement('div');
              wrapper.className = 'page-wrapper';
              wrapper.style.width = viewport.width + 'px';
              wrapper.style.height = viewport.height + 'px';
              wrapper.style.position = 'relative';
              wrapper.dataset.pageNum = pageNum;
              
              const canvas = document.createElement('canvas');
              canvas.width = viewport.width;
              canvas.height = viewport.height;
              wrapper.appendChild(canvas);
              
              const layer = document.createElement('div');
              layer.className = 'anno-layer';
              layer.style.width = viewport.width + 'px';
              layer.style.height = viewport.height + 'px';
              layer.dataset.page = pageNum;
              wrapper.appendChild(layer);
              
              const pageNumber = document.createElement('div');
              pageNumber.className = 'page-number';
              pageNumber.textContent = `P√°gina ${pageNum}`;
              wrapper.appendChild(pageNumber);
              
              // A√±adir al contenedor ANTES de renderizar
              container.appendChild(wrapper);
              pageWrappers.push(wrapper);
              
              const renderContext = {
                canvasContext: canvas.getContext('2d'),
                viewport: viewport
              };
              
              await page.render(renderContext).promise;
              
              // Event listener para crear notas
              wrapper.addEventListener('click', (e) => {
                if (creatingNote) {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  const rect = wrapper.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const y = e.clientY - rect.top;
                  
                  createTextarea(x, y, null, layer);
                  creatingNote = false;
                  document.body.classList.remove('creating-note');
                }
              });
              
              console.log(`P√°gina ${pageNum} renderizada completamente.`);
              
            } catch (error) {
              console.error(`Error renderizando p√°gina ${pageNum}:`, error);
            }
          }
          
          console.log('Todas las p√°ginas renderizadas completamente.');
          
        } finally {
          isRendering = false; // IMPORTANTE: Liberar el flag al final
        }
      }

      // ========================================
      // EVENT LISTENERS PARA CARGA DE ARCHIVOS
      // ========================================
      
      uploadArea.addEventListener('click', (e) => {
        console.log('Click en √°rea de carga');
        fileInput.click();
      });
      
      uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.classList.add('dragover');
      });
      
      uploadArea.addEventListener('dragleave', (e) => {
        uploadArea.classList.remove('dragover');
      });
      
      uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        console.log('Archivos arrastrados:', files.length);
        
        if (files.length > 0) {
          const file = files[0];
          console.log('Archivo:', file.name, file.type);
          
          if (file.type === 'application/pdf') {
            const url = URL.createObjectURL(file);
            loadPdf(url, file.name);
          } else {
            showToast('Por favor selecciona un archivo PDF', 'error');
          }
        }
      });

      fileInput.addEventListener('change', (e) => {
        console.log('Archivo seleccionado');
        const file = e.target.files[0];
        
        if (file) {
          console.log('Archivo:', file.name, file.type);
          
          if (file.type === 'application/pdf') {
            const url = URL.createObjectURL(file);
            loadPdf(url, file.name);
          } else {
            showToast('Por favor selecciona un archivo PDF', 'error');
          }
        }
      });

      // ========================================
      // CONTROLES B√ÅSICOS
      // ========================================
      
      zoomInBtn.addEventListener('click', () => {
        currentZoom = Math.min(currentZoom + 0.25, 3.0);
        updateZoom();
      });

      zoomOutBtn.addEventListener('click', () => {
        currentZoom = Math.max(currentZoom - 0.25, 0.25);
        updateZoom();
      });

      // FUNCI√ìN MEJORADA: updateZoom con mejor control de estado
      async function updateZoom() {
        // Evitar m√∫ltiples llamadas simult√°neas
        if (isRendering) {
          console.log('Renderizado en progreso, saltando zoom...');
          return;
        }
        
        zoomDisplay.textContent = Math.round(currentZoom * 100) + '%';
        
        if (pdfDoc) {
          console.log('Aplicando zoom:', currentZoom);
          await renderAllPages(); // Esperamos a que todas las p√°ginas se redibujen
          
          // Despu√©s de redibujar, volvemos a cargar las notas
          if (directoryHandle && currentPdfName) {
            setTimeout(() => {
              loadNotesFromFile();
            }, 200); // Peque√±o delay para asegurar que el DOM est√© listo
          }
        }
      }

      fullscreenBtn.addEventListener('click', toggleFullscreen);

      function toggleFullscreen() {
        isFullscreen = !isFullscreen;
        if (isFullscreen) {
          document.body.classList.add('fullscreen');
          fullscreenBtn.textContent = '‚õ∑';
        } else {
          document.body.classList.remove('fullscreen');
          fullscreenBtn.textContent = '‚õ∂';
        }
      }

      backBtn.addEventListener('click', () => {
        dropZone.classList.remove('hidden');
        
        // Limpiar completamente
        clearContainer();
        
        fileInfo.textContent = 'Visor PDF';
        backBtn.disabled = true;
        pdfDoc = null;
        hidePopup();
        creatingNote = false;
        document.body.classList.remove('creating-note');
        currentPage = 1;
        totalPages = 0;
        currentPdfName = null;
        isRendering = false; // Resetear flag de renderizado
        
        if (directoryHandle) {
          updateFileStatus('saved', 'Carpeta configurada');
        } else {
          updateFileStatus('no-access', 'Sin acceso');
        }
      });

      // ========================================
      // SISTEMA DE PERSISTENCIA DE ARCHIVOS
      // ========================================
      
      function supportsFileSystemAccess() {
        return 'showDirectoryPicker' in window;
      }

      function showPermissionModal() {
        if (!supportsFileSystemAccess()) {
          showToast('Tu navegador no soporta guardado autom√°tico de archivos', 'error');
          updateFileStatus('error', 'No compatible');
          return;
        }
        document.getElementById('permission-modal').classList.remove('hidden');
      }

      function hidePermissionModal() {
        document.getElementById('permission-modal').classList.add('hidden');
      }

      // Inicializar IndexedDB para guardar el handle de la carpeta
      async function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open('PDFViewerDB', 1);
          
          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            db = request.result;
            resolve(db);
          };
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('settings')) {
              db.createObjectStore('settings', { keyPath: 'id' });
            }
          };
        });
      }

      // Cargar el handle de la carpeta guardado
      async function loadDirectoryHandle() {
        if (!db || !supportsFileSystemAccess()) {
          updateFileStatus('no-access', 'Sin acceso');
          return;
        }

        try {
          const transaction = db.transaction(['settings'], 'readonly');
          const store = transaction.objectStore('settings');
          const request = store.get('notesFolder');
          
          request.onsuccess = async () => {
            const result = request.result;
            if (result && result.handle) {
              const handle = result.handle;
              // Verificar si el permiso sigue vigente
              const permissionStatus = await handle.queryPermission({ mode: 'readwrite' });
              
              if (permissionStatus === 'granted') {
                directoryHandle = handle;
                updateFileStatus('saved', 'Acceso concedido');
                showToast('Carpeta de notas recordada', 'info');
              } else {
                updateFileStatus('no-access', 'Acceso denegado');
                showToast('Acceso a carpeta de notas perdido. Config√∫rala de nuevo.', 'info');
              }
            } else {
              updateFileStatus('no-access', 'Sin acceso');
            }
          };

          request.onerror = (e) => {
            console.error('Error al cargar handle de carpeta:', e.target.error);
            updateFileStatus('no-access', 'Error de carga');
          };
        } catch (error) {
          console.error('Error al cargar handle de carpeta (catch):', error);
          updateFileStatus('no-access', 'Error de carga');
        }
      }

      // Solicitar y guardar acceso a directorio
      async function requestDirectoryAccess() {
        try {
          const newDirectoryHandle = await window.showDirectoryPicker({
            mode: 'readwrite'
          });
          
          const permission = await newDirectoryHandle.requestPermission({ mode: 'readwrite' });
          if (permission === 'granted') {
            directoryHandle = newDirectoryHandle;
            
            // Guardar el handle en IndexedDB
            const transaction = db.transaction(['settings'], 'readwrite');
            const store = transaction.objectStore('settings');
            await store.put({ id: 'notesFolder', handle: directoryHandle });

            updateFileStatus('saved', 'Acceso concedido');
            showToast('Carpeta configurada correctamente', 'success');
            hidePermissionModal();
            
            if (currentPdfName) {
              setTimeout(loadNotesFromFile, 500);
            }
          } else {
            throw new Error('Permisos denegados');
          }
        } catch (error) {
          console.error('Error solicitando acceso:', error);
          if (error.name !== 'AbortError') {
            showToast('Error configurando carpeta', 'error');
            updateFileStatus('error', 'Error de acceso');
          }
        }
      }

      function getNotesFileName(pdfName) {
        const cleanName = pdfName.replace(/[^a-zA-Z0-9.-]/g, '_');
        return `${cleanName}_notas.json`;
      }

      async function saveNotesToFile() {
        if (!directoryHandle || !currentPdfName) {
          updateFileStatus('no-access', 'Sin acceso');
          return;
        }
        
        if (saveTimeout) {
          clearTimeout(saveTimeout);
        }
        
        saveTimeout = setTimeout(async () => {
          try {
            updateFileStatus('saving', 'Guardando...');
            
            const notes = collectAllNotes();
            const data = {
              pdfName: currentPdfName,
              timestamp: Date.now(),
              notes: notes,
              totalPages: totalPages,
              zoom: currentZoom,
              version: '2.0'
            };
            
            const fileName = getNotesFileName(currentPdfName);
            const fileHandle = await directoryHandle.getFileHandle(fileName, { create: true });
            const writable = await fileHandle.createWritable();
            
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            
            updateFileStatus('saved', `${notes.length} notas guardadas`);
            console.log(`Guardadas ${notes.length} notas en ${fileName}`);
            
          } catch (error) {
            console.error('Error guardando notas:', error);
            updateFileStatus('error', 'Error guardando');
            showToast('Error guardando notas autom√°ticamente', 'error');
          }
        }, 1000);
      }

      async function loadNotesFromFile() {
        if (!directoryHandle || !currentPdfName) {
          updateFileStatus('no-access', 'Sin acceso');
          return;
        }
        
        try {
          const fileName = getNotesFileName(currentPdfName);
          const fileHandle = await directoryHandle.getFileHandle(fileName);
          const file = await fileHandle.getFile();
          const text = await file.text();
          const data = JSON.parse(text);
          
          if (data.notes && Array.isArray(data.notes)) {
            document.querySelectorAll('.note-icon').forEach(icon => icon.remove());
            
            data.notes.forEach(note => {
              const layer = document.querySelector(`[data-page="${note.pageNum}"]`);
              if (layer) {
                // Asegurarse de que las coordenadas se escalen correctamente con el zoom actual
                // Las notas se guardan como porcentajes (x, y), as√≠ que se aplican al tama√±o actual de la capa
                const x = note.x * layer.offsetWidth;
                const y = note.y * layer.offsetHeight;
                addNoteIcon(x, y, note.content, layer);
              }
            });
            
            updateFileStatus('saved', `${data.notes.length} notas cargadas`);
            console.log(`Cargadas ${data.notes.length} notas desde ${fileName}`);
          }
          
        } catch (error) {
          if (error.name === 'NotFoundError') {
            updateFileStatus('saved', 'Sin notas previas');
            console.log('No hay archivo de notas previo');
          } else {
            console.error('Error cargando notas:', error);
            updateFileStatus('error', 'Error cargando');
          }
        }
      }

      function collectAllNotes() {
        const notes = [];
        document.querySelectorAll('.anno-layer').forEach(layer => {
          const pageNum = parseInt(layer.dataset.page);
          const pageWidth = layer.offsetWidth;
          const pageHeight = layer.offsetHeight;
          
          layer.querySelectorAll('.note-icon').forEach(icon => {
            const x = parseInt(icon.style.left);
            const y = parseInt(icon.style.top);
            
            notes.push({
              content: icon.dataset.content, // El contenido ya est√° procesado para guardar
              x: x / pageWidth, // Guardar como porcentaje
              y: y / pageHeight, // Guardar como porcentaje
              pageNum: pageNum
            });
          });
        });
        return notes;
      }

      // Event listeners para persistencia
      document.getElementById('folder-btn').addEventListener('click', () => {
        showPermissionModal();
      });

      document.getElementById('grant-access-btn').addEventListener('click', requestDirectoryAccess);

      document.getElementById('skip-access-btn').addEventListener('click', () => {
        hidePermissionModal();
        updateFileStatus('no-access', 'Sin acceso');
        showToast('Puedes configurar la carpeta m√°s tarde', 'info');
      });

      // ========================================
      // NAVEGACI√ìN Y CONTROLES DE TECLADO
      // ========================================
      
      function getCurrentPage() {
        const pageWrappers = document.querySelectorAll('.page-wrapper');
        const containerRect = container.getBoundingClientRect();
        const containerCenter = containerRect.top + containerRect.height / 2;
        
        let closestPage = 1;
        let closestDistance = Infinity;
        
        pageWrappers.forEach(wrapper => {
          const rect = wrapper.getBoundingClientRect();
          const pageCenter = rect.top + rect.height / 2;
          const distance = Math.abs(pageCenter - containerCenter);
          
          if (distance < closestDistance) {
            closestDistance = distance;
            closestPage = parseInt(wrapper.dataset.pageNum);
          }
        });
        
        return closestPage;
      }

      function scrollToPage(pageNum) {
        const pageWrapper = document.querySelector(`[data-page-num="${pageNum}"]`);
        if (pageWrapper) {
          pageWrapper.scrollIntoView({
            behavior: 'instant',
            block: 'start'
          });
          
          currentPage = pageNum;
          showNavIndicator(`P√°gina ${pageNum}/${totalPages}`);
        }
      }

      function scrollVertical(direction) {
        const scrollAmount = 100;
        const currentScroll = container.scrollTop;
        const newScroll = direction === 'up' ? 
          Math.max(0, currentScroll - scrollAmount) :
          currentScroll + scrollAmount;
        
        container.scrollTo({
          top: newScroll,
          behavior: 'smooth'
        });
        
        setTimeout(() => {
          currentPage = getCurrentPage();
          showNavIndicator(`Scroll: ${currentPage}/${totalPages}`);
        }, 100);
      }

      function showNavIndicator(text) {
        // Asegurarse de que navIndicator est√© actualizado
        if (!navIndicator || !document.body.contains(navIndicator)) {
          navIndicator = document.getElementById('nav-indicator');
        }
        if (navIndicator) {
          navIndicator.textContent = text;
          navIndicator.classList.add('show');
          
          setTimeout(() => {
            navIndicator.classList.remove('show');
          }, 1500);
        }
      }

      // Controles de teclado
      document.addEventListener('keydown', function(e) {
        const activeElement = document.activeElement;
        const isEditing = activeElement && (
          activeElement.contentEditable === 'true' || 
          activeElement.tagName === 'TEXTAREA' ||
          activeElement.tagName === 'INPUT' ||
          activeElement.classList.contains('mq-editable-field')
        );

        if (e.key.toLowerCase() === 'f' && !e.repeat && !e.ctrlKey && !isEditing) {
          e.preventDefault();
          if (pdfDoc) {
            toggleFullscreen();
          }
        }

        if (e.key.toLowerCase() === 'n' && !e.repeat && !e.ctrlKey && !isEditing) {
          e.preventDefault();
          
          if (!pdfDoc) return;
          
          creatingNote = !creatingNote;
          if (creatingNote) {
            document.body.classList.add('creating-note');
          } else {
            document.body.classList.remove('creating-note');
          }
        }

        if (!isEditing && pdfDoc) {
          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            const targetPage = getCurrentPage();
            
            if (e.key === 'ArrowLeft' && targetPage > 1) {
              scrollToPage(targetPage - 1);
            } else if (e.key === 'ArrowRight' && targetPage < totalPages) {
              scrollToPage(targetPage + 1);
            }
          }
          
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            scrollVertical(e.key === 'ArrowUp' ? 'up' : 'down');
          }
        }
        
        if (e.key === 'Escape') {
          hidePopup();
          creatingNote = false;
          document.body.classList.remove('creating-note');
          if (isFullscreen) {
            toggleFullscreen();
          }
        }
        
        if (e.ctrlKey && e.key === '+') {
          e.preventDefault();
          zoomInBtn.click();
        }
        if (e.ctrlKey && e.key === '-') {
          e.preventDefault();
          zoomOutBtn.click();
        }
        if (e.ctrlKey && e.key === '0') {
          e.preventDefault();
          currentZoom = 1.0;
          updateZoom();
        }
      });

      container.addEventListener('wheel', (e) => {
        if (e.ctrlKey) {
          e.preventDefault();
          if (e.deltaY < 0) {
            zoomInBtn.click();
          } else {
            zoomOutBtn.click();
          }
        }
      });

      // ========================================
      // SISTEMA DE NOTAS
      // ========================================
      
      function createTextarea(x, y, icon, targetLayer) {
        const textarea = document.createElement('div');
        textarea.contentEditable = 'true';
        textarea.className = 'note-textarea';
        
        const pageRect = targetLayer.closest('.page-wrapper').getBoundingClientRect();
        textarea.style.left = (pageRect.left + x) + 'px';
        textarea.style.top = (pageRect.top + y) + 'px';
        
        if (icon) {
          renderContentInElement(textarea, processNoteContent(icon.dataset.content));
        } else {
          textarea.innerHTML = '<p></p>';
        }
        
        document.body.appendChild(textarea);
        textarea.focus();

        textarea.addEventListener('keydown', (ev) => {
          if (ev.ctrlKey && ev.key.toLowerCase() === 'l') {
            ev.preventDefault();
            ev.stopPropagation();
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0);
            range.deleteContents();
            const span = document.createElement('span');
            span.className = 'math-field';
            span.setAttribute('contenteditable', 'false');
            range.insertNode(span);
            range.setStartAfter(span);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            enhanceMathField(span);
            setTimeout(() => {
              span._mqInstance.focus();
            }, 10);
            return;
          }
          if (ev.key === 'Escape') {
            ev.preventDefault();
            ev.stopPropagation();
            document.body.removeChild(textarea);
            return;
          }
        });

        textarea.addEventListener('blur', (ev) => {
          if (ev.relatedTarget && ev.relatedTarget.closest('.note-textarea')) {
            return;
          }
          
          // Capturar el contenido, asegurando que los campos MathQuill se conviertan a su representaci√≥n LaTeX
          const tempDiv = document.createElement('div');
          Array.from(textarea.childNodes).forEach(node => tempDiv.appendChild(node.cloneNode(true)));
          // Iterar sobre todos los math-field spans en el div temporal
          tempDiv.querySelectorAll('span.math-field').forEach(span => {
            if (span._mqInstance) { // Si es una instancia activa de MathQuill
              const latex = span._mqInstance.latex();
              // Reemplazar el contenido del span con el LaTeX rodeado de $
              span.textContent = `$${latex}$`; 
            }
          });
          const content = tempDiv.innerHTML.trim(); // Este es el contenido a guardar

          document.body.removeChild(textarea);
          if (content && content !== '<p></p>') {
            if (icon) {
              icon.dataset.content = content; // Guardar el HTML procesado
              hidePopup();
              showPopup(icon); // Re-renderizar popup con el nuevo contenido
            } else {
              addNoteIcon(x, y, content, targetLayer);
            }
            
            setTimeout(saveNotesToFile, 100);
          }
        });
      }

      function processNoteContent(content) {
        // Esta funci√≥n se llama al establecer innerHTML para textarea o popup.
        // Asegura que los campos MathQuill est√©n listos para ser inicializados.
        // El contenido guardado tendr√° <span class="math-field">$latex$</span>
        // Necesitamos quitar los $...$ y dejar solo el latex para que MQ.MathField lo recoja.
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        tempDiv.querySelectorAll('span.math-field').forEach(span => {
          const textContent = span.textContent;
          if (textContent.startsWith('$') && textContent.endsWith('$')) {
            span.textContent = textContent.substring(1, textContent.length - 1); // Quitar $
          }
        });
        return tempDiv.innerHTML;
      }

      function enhanceMathField(span) {
        if (span._mqInstance) return; // Evitar re-inicializar
        
        const initialLatex = span.textContent; // Obtener el contenido LaTeX (sin $)
        span.textContent = ''; // Limpiar el span antes de inicializar MathQuill
        const mf = MQ.MathField(span, {
          spaceBehavesLikeTab: true,
          handlers: { edit: () => console.log('LaTeX:', mf.latex()) }
        });
        span._mqInstance = mf;
        if (initialLatex) {
          mf.latex(initialLatex); // Establecer el contenido LaTeX
        }
      }

      function initMathFields(root = document) {
        root.querySelectorAll('span.math-field').forEach(enhanceMathField);
      }

      function addNoteIcon(x, y, content, targetLayer) {
        const icon = document.createElement('span');
        icon.textContent = 'üìù';
        icon.className = 'note-icon';
        icon.dataset.content = content;
        icon.style.left = x + 'px';
        icon.style.top = y + 'px';
        icon.title = 'Doble clic para editar, arrastra para mover';
        
        targetLayer.appendChild(icon);
        
        addDragHandlers(icon, targetLayer);
        addHoverHandlers(icon);
        icon.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          hidePopup();
          createTextarea(parseInt(icon.style.left), parseInt(icon.style.top), icon, targetLayer);
        });
      }

      function showPopup(icon) {
        hidePopup();
        const popup = document.createElement('div');
        popup.className = 'note-popup';
        
        renderContentInElement(popup, processNoteContent(icon.dataset.content));
        
        const iconRect = icon.getBoundingClientRect();
        popup.style.left = (iconRect.left + window.scrollX) + 'px';
        popup.style.top = (iconRect.bottom + window.scrollY + 5) + 'px';
        
        document.body.appendChild(popup);
        activePopup = popup;
        activeIcon = icon;
        
        popup.addEventListener('mouseleave', () => {
          setTimeout(() => {
            if (!popup.matches(':hover') && !icon.matches(':hover')) {
              hidePopup();
            }
          }, 100);
        });
      }

      function hidePopup() {
        if (activePopup) {
          activePopup.remove();
          activePopup = null;
          activeIcon = null;
        }
      }

      function addHoverHandlers(icon) {
        icon.addEventListener('mouseenter', () => showPopup(icon));
        icon.addEventListener('mouseleave', () => {
          setTimeout(() => {
            if (!activePopup || (!activePopup.matches(':hover') && !icon.matches(':hover'))) {
              hidePopup();
            }
          }, 100);
        });
      }

      function addDragHandlers(icon, targetLayer) {
        let offsetX = 0, offsetY = 0;
        let isDragging = false;
        let startY = 0;
        
        function onMouseDown(e) {
          e.preventDefault();
          e.stopPropagation();
          isDragging = false;
          
          const iconRect = icon.getBoundingClientRect();
          const layerRect = targetLayer.getBoundingClientRect();
          
          offsetX = e.clientX - iconRect.left;
          offsetY = e.clientY - iconRect.top;
          startY = e.clientY;
          
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        }
        
        function onMouseMove(e) {
          e.preventDefault();
          if (!isDragging) {
            isDragging = true;
            icon.classList.add('dragging');
            hidePopup();
          }
          
          const layerRect = targetLayer.getBoundingClientRect();
          const x = e.clientX - layerRect.left - offsetX;
          const y = e.clientY - layerRect.top - offsetY;
          
          const dragDistance = startY - e.clientY;
          if (dragDistance > 100) {
            icon.classList.add('deleting');
          } else {
            icon.classList.remove('deleting');
          }
          
          const maxX = targetLayer.offsetWidth;
          const maxY = targetLayer.offsetHeight;
          
          icon.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
          icon.style.top = Math.max(-200, Math.min(y, maxY)) + 'px';
        }
        
        function onMouseUp(e) {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          icon.classList.remove('dragging');
          
          const dragDistance = startY - e.clientY;
          if (dragDistance > 100 || icon.classList.contains('deleting')) {
            icon.remove();
            hidePopup();
            setTimeout(saveNotesToFile, 100);
            return;
          }
          
          icon.classList.remove('deleting');
          isDragging = false;
          setTimeout(saveNotesToFile, 100);
        }
        
        icon.addEventListener('mousedown', onMouseDown);
      }

      document.addEventListener('click', (e) => {
        if (!e.target.classList.contains('note-icon') &&
            !e.target.closest('.note-popup') &&
            !e.target.closest('.note-textarea')) {
          hidePopup();
        }
      });

      // ========================================
      // MODAL DE INFORMACI√ìN
      // ========================================
      const infoBtn = document.getElementById('info-btn');
      const infoModal = document.getElementById('info-modal');
      const closeInfo = document.querySelector('.close-info');

      infoBtn.addEventListener('click', () => {
        infoModal.classList.remove('hidden');
      });

      closeInfo.addEventListener('click', () => {
        infoModal.classList.add('hidden');
      });

      infoModal.addEventListener('click', (e) => {
        if (e.target === infoModal) {
          infoModal.classList.add('hidden');
        }
      });

      // ========================================
      // INICIALIZACI√ìN
      // ========================================
      
      // Inicializar IndexedDB y cargar el handle de la carpeta
      initDB().then(() => {
        console.log('IndexedDB inicializado.');
        loadDirectoryHandle(); // Intentar cargar el handle guardado
      }).catch(error => {
        console.error('Error al inicializar IndexedDB:', error);
        showToast('Error al inicializar la base de datos local.', 'error');
        updateFileStatus('error', 'DB Error');
      });

      console.log('Visor PDF inicializado correctamente');
    });
  </script>
</body>
</html>

Los principales cambios que hice para arreglar el problema de duplicaci√≥n de p√°ginas al aplicar zoom son:

## üîß **Cambios Principales:**

1. **Nueva funci√≥n `clearContainer()`**: Limpia completamente el contenedor DOM y resetea todas las variables relacionadas
2. **Flag `isRendering`**: Previene renderizados m√∫ltiples simult√°neos que causaban la duplicaci√≥n
3. **Mejor manejo del `navIndicator`**: Se re-crea correctamente despu√©s de limpiar el contenedor
4. **Funci√≥n `updateZoom()` mejorada**: Ahora verifica el estado de renderizado antes de proceder
5. **Limpieza m√°s robusta**: Remueve event listeners y referencias DOM antes de limpiar

## üéØ **Problemas Solucionados:**

- ‚úÖ **Duplicaci√≥n de p√°ginas**: El flag `isRendering` evita renderizados simult√°neos
- ‚úÖ **Referencias colgantes**: `clearContainer()` limpia completamente el DOM y variables
- ‚úÖ **Timing issues**: Mejor control de cu√°ndo se ejecutan las operaciones de renderizado
- ‚úÖ **Memory leaks**: Limpieza adecuada de event listeners y referencias DOM

## üöÄ **Funcionalidades Mantenidas:**

- Navegaci√≥n h√≠brida (flechas + scroll)
- Sistema de notas con LaTeX
- Guardado autom√°tico de notas
- Zoom con Ctrl + rueda del mouse
- Pantalla completa
- Persistencia de archivos

Ahora el zoom deber√≠a funcionar correctamente sin duplicar p√°ginas. El sistema es m√°s robusto y maneja mejor los estados de renderizado.

